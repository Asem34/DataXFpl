<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataXFPL</title>
    <!-- Include Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom class for the filter container to allow relative positioning */
        #filter-tabs-container {
            position: relative;
        }
        /* Style for the moving indicator (Lime Accent: #aeff00) */
        #filter-indicator {
            position: absolute;
            height: 3px;
            background-color: #aeff00;
            bottom: 0px;
            transition: all 300ms cubic-bezier(0.4, 0, 0.2, 1); /* Tailwind's ease-in-out */
        }
        /* Custom class for the active tab (Lime Accent: #aeff00) */
        .tab-active {
            color: #aeff00; 
        }
        /* Custom scrollbar for better look in dark mode */
        .player-list::-webkit-scrollbar {
            width: 8px;
        }
        /* Background Color (Black but slightly blue: #10141f) */
        .player-list::-webkit-scrollbar-track {
            background: #10141f; 
        }
        .player-list::-webkit-scrollbar-thumb {
            background: #4b5563; /* Gray-600 */
            border-radius: 4px;
        }
        /* Accent color on hover (Lime Accent: #aeff00) */
        .player-list::-webkit-scrollbar-thumb:hover {
            background: #aeff00; 
        }
        /* Custom Glow effect for cards on hover using the lime accent */
        .shadow-lime-glow:hover {
            box-shadow: 0 0 15px rgba(174, 255, 0, 0.5); 
            border-color: #aeff00;
        }
    </style>
</head>
<!-- Applying custom background color #10141f (Black, slightly blue) -->
<body class="bg-[#10141f] text-gray-100 min-h-screen p-4 sm:p-8">

    <div class="container max-w-6xl mx-auto">
        
        <header class="text-center mb-8">
            <!-- Applying custom accent color #aeff00 to the title -->
            <h1 class="text-3xl sm:text-4xl font-bold text-[#aeff00] tracking-wider">DataXFPL</h1>
            <p class="text-gray-400 mt-2">Analyze player performance and predicted points. (GW16)</p>
        </header>

        <!-- Search and Filter Controls -->
        <!-- Using a slightly brighter background for the control panel to lift it off the main background -->
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl mb-6">
            
            <!-- Search Input -->
            <div class="mb-4">
                <input type="text" id="search-input" placeholder="Search by player or team name..."
                       class="w-full p-3 rounded-lg bg-gray-700 text-gray-100 border border-gray-600 
                       focus:border-[#aeff00] focus:ring focus:ring-[#aeff00] focus:ring-opacity-50 transition duration-150">
            </div>

            <!-- Position Filters with Dynamic Underline -->
            <div id="filter-tabs-container" class="border-b border-gray-700">
                <div id="filter-tabs" class="flex justify-center space-x-2 sm:space-x-4">
                    <!-- Note: Removed border-b-2 from tabs, handled by indicator now -->
                    <button class="tab-item px-4 py-2 text-sm font-medium transition-colors" data-filter="All">All</button>
                    <button class="tab-item px-4 py-2 text-sm font-medium hover:text-gray-300 transition-colors" data-filter="FWD">FWD</button>
                    <button class="tab-item px-4 py-2 text-sm font-medium hover:text-gray-300 transition-colors" data-filter="MID">MID</button>
                    <button class="tab-item px-4 py-2 text-sm font-medium hover:text-gray-300 transition-colors" data-filter="DEF">DEF</button>
                    <button class="tab-item px-4 py-2 text-sm font-medium hover:text-gray-300 transition-colors" data-filter="GK">GK</button>
                </div>
                <!-- Dynamic Underline Indicator -->
                <div id="filter-indicator"></div>
            </div>

        </div>

        <!-- Results Container -->
        <div id="results-container" class="player-list grid gap-6 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 max-h-[70vh] overflow-y-auto">
            <!-- Player cards will be injected here -->
            <div class="col-span-full text-center text-gray-400 p-8" id="loading-message">Loading player data...</div>
        </div>
        
    </div>

    <script type="module">
        // Global state
        let allPlayers = [];
        let currentFilter = 'All';
        let currentSearch = '';

        // DOM Elements
        const resultsContainerEl = document.getElementById('results-container');
        const searchInputEl = document.getElementById('search-input');
        const filterTabs = document.querySelectorAll('.tab-item');
        const loadingMessageEl = document.getElementById('loading-message');
        const filterIndicator = document.getElementById('filter-indicator');
        const filterTabsContainer = document.getElementById('filter-tabs');


        /**
         * Function to move the dynamic underline to the active tab.
         * @param {HTMLElement} activeTab - The currently active filter button.
         */
        function moveIndicator(activeTab) {
            if (!activeTab) return;

            // Get positions relative to the filterTabsContainer
            const containerRect = filterTabsContainer.getBoundingClientRect();
            const tabRect = activeTab.getBoundingClientRect();

            // Calculate the position and width for the indicator
            const leftPosition = tabRect.left - containerRect.left;
            const width = tabRect.width;

            filterIndicator.style.left = `${leftPosition}px`;
            filterIndicator.style.width = `${width}px`;
        }

        /**
         * 1. Fetch and Parse CSV Data
         * Fetches the predicted_points.csv file and parses it into a usable array of player objects.
         */
        async function fetchAndParseData() {
            const csvFilePath = 'predicted_points.csv'; 
            
            try {
                const response = await fetch(csvFilePath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const csvText = await response.text();
                
                const lines = csvText.trim().split('\n');
                if (lines.length < 2) {
                    loadingMessageEl.textContent = 'No data found in CSV file.';
                    return;
                }

                const headers = lines[0].split(',');
                allPlayers = lines.slice(1).map(line => {
                    const values = line.split(',');
                    const player = {};
                    headers.forEach((header, i) => {
                        const key = header.trim();
                        let value = values[i].trim();

                        if (['goals', 'assists', 'Def_Con_Per_90', 'Def_Con_Bonus', 'Team_Clean_Sheet_Prob', 'Predicted_Points'].includes(key)) {
                            value = parseFloat(value) || 0.0;
                        }
                        
                        if (key === 'full_name') player.name = value;
                        else if (key === 'Team_Name') player.team = value;
                        else if (key === 'position') player.position = value;
                        else if (key === 'vs') player.opponent = value;
                        else if (key === 'Team_Clean_Sheet_Prob') player.csProb = value;
                        else if (key === 'Predicted_Points') player.predictedPoints = value;
                        else {
                            player[key] = value;
                        }
                    });
                    return player;
                });

                loadingMessageEl.classList.add('hidden');
                // Initial render and indicator placement
                renderPlayers();
                const initialActiveTab = document.querySelector('.tab-item[data-filter="All"]');
                if (initialActiveTab) {
                    initialActiveTab.classList.add('tab-active');
                    // Use setTimeout to ensure the layout is settled before calculating position
                    setTimeout(() => moveIndicator(initialActiveTab), 50);
                }

            } catch (error) {
                console.error('Error fetching or parsing CSV:', error);
                loadingMessageEl.textContent = 'Failed to load data. Please check the console for details.';
            }
        }

        /**
         * 2. Main Rendering Logic
         */
        function renderPlayers() {
            const searchLower = currentSearch.toLowerCase();
            const filteredPlayers = allPlayers
                .filter(player => {
                    if (currentFilter !== 'All' && player.position !== currentFilter) {
                        return false;
                    }
                    return player.name.toLowerCase().includes(searchLower) || 
                           player.team.toLowerCase().includes(searchLower);
                });

            const sortedPlayers = filteredPlayers.sort((a, b) => b.predictedPoints - a.predictedPoints);

            resultsContainerEl.innerHTML = '';
            
            if (sortedPlayers.length === 0) {
                resultsContainerEl.innerHTML = `<div class="col-span-full text-center text-gray-500 p-8">No players match the current filters or search term.</div>`;
                return;
            }

            sortedPlayers.forEach(player => {
                const card = createPlayerCard(player);
                resultsContainerEl.appendChild(card);
            });
        }

        /**
         * 3. Create Player Card Element (Updated Layout with conditional logic)
         */
        function createPlayerCard(player) {
            const card = document.createElement('div');
            
            // Determine position color for the badge
            let positionColor = 'bg-gray-500'; 
            if (player.position === 'FWD') positionColor = 'bg-red-600';
            else if (player.position === 'MID') positionColor = 'bg-green-600';
            else if (player.position === 'DEF') positionColor = 'bg-blue-600';
            else if (player.position === 'GK') positionColor = 'bg-purple-600';
            
            // Use a unified dark blue background for the card body
            card.className = `p-5 rounded-xl border border-gray-700 shadow-md transition-all duration-300 shadow-lime-glow bg-[#1e2738]`;
            
            // --- Conditional Layout Generation ---
            let middleSectionHTML = '';
            let bottomSectionHTML = '';

            const isAttacking = player.position === 'FWD' || player.position === 'MID';

            if (isAttacking) {
                // Layout for FWD and MID: CS Prob. moved to raw stats, 2 columns for key metrics
                middleSectionHTML = `
                    <div class="grid grid-cols-2 gap-4 text-center">
                        <div>
                            <p class="text-xs uppercase text-gray-400">Predicted Points</p>
                            <p class="text-4xl font-black text-[#aeff00] leading-none mt-1">${player.predictedPoints.toFixed(2)}</p>
                        </div>
                        <div>
                            <p class="text-xs uppercase text-gray-400">Goals</p>
                            <p class="text-4xl font-black text-[#aeff00] leading-none mt-1">${player.goals.toFixed(2)}</p>
                        </div>
                    </div>
                `;
                // Remaining raw stats: Assists, Def. Cons., and CS Prob. (3 columns)
                bottomSectionHTML = `
                    <div class="grid grid-cols-3 gap-2 text-center border-t border-gray-700 pt-3 mt-4">
                        <div>
                            <p class="text-gray-400 text-xs uppercase">Assists</p>
                            <p class="font-semibold text-lg">${player.assists.toFixed(2)}</p>
                        </div>
                        <div>
                            <p class="text-gray-400 text-xs uppercase">Def. Cons.</p>
                            <p class="font-semibold text-lg">${player.Def_Con_Per_90.toFixed(2)}</p>
                        </div>
                        <div>
                            <p class="text-gray-400 text-xs uppercase">CS Prob.</p>
                            <p class="font-semibold text-lg">${(player.csProb * 100).toFixed(1)}%</p>
                        </div>
                    </div>
                `;
            } else {
                // Layout for DEF and GK: Goals remains in raw stats, 2 columns for key metrics
                middleSectionHTML = `
                    <div class="grid grid-cols-2 gap-4 text-center">
                        <div>
                            <p class="text-xs uppercase text-gray-400">Predicted Points</p>
                            <p class="text-4xl font-black text-[#aeff00] leading-none mt-1">${player.predictedPoints.toFixed(2)}</p>
                        </div>
                        <div>
                            <p class="text-xs uppercase text-gray-400">Clean Sheet Prob.</p>
                            <p class="text-4xl font-black text-[#aeff00] leading-none mt-1">${(player.csProb * 100).toFixed(1)}%</p>
                        </div>
                    </div>
                `;
                // Remaining raw stats: Goals, Assists, and Def. Cons. (Original layout)
                bottomSectionHTML = `
                    <div class="grid grid-cols-3 gap-2 text-center border-t border-gray-700 pt-3 mt-4">
                        <div>
                            <p class="text-gray-400 text-xs uppercase">Goals</p>
                            <p class="font-semibold text-lg">${player.goals.toFixed(2)}</p>
                        </div>
                        <div>
                            <p class="text-gray-400 text-xs uppercase">Assists</p>
                            <p class="font-semibold text-lg">${player.assists.toFixed(2)}</p>
                        </div>
                        <div>
                            <p class="text-gray-400 text-xs uppercase">Def. Cons.</p>
                            <p class="font-semibold text-lg">${player.Def_Con_Per_90.toFixed(2)}</p>
                        </div>
                    </div>
                `;
            }
            // --- End Conditional Layout Generation ---

            card.innerHTML = `
                <!-- TOP SECTION: Name, Team, Opponent -->
                <div class="mb-4 border-b border-gray-700 pb-3">
                    <div class="flex items-center justify-between mb-1">
                        <h2 class="text-2xl font-extrabold text-gray-50">${player.name}</h2>
                        <span class="text-sm font-semibold text-gray-100 px-3 py-1 rounded-full ${positionColor}">${player.position}</span>
                    </div>
                    <p class="text-md font-semibold text-gray-400">
                        ${player.team} 
                        <span class="text-sm text-gray-500 font-normal">vs ${player.opponent}</span>
                    </p>
                </div>

                <!-- MIDDLE SECTION: Key Metrics (CONDITIONAL) -->
                ${middleSectionHTML}

                <!-- BOTTOM SECTION: Raw Stats (CONDITIONAL) -->
                ${bottomSectionHTML}
            `;
            return card;
        }

        /**
         * 4. Set up Event Listeners
         */
        
        // Search input
        searchInputEl.addEventListener('input', (e) => {
            currentSearch = e.target.value;
            // Debounce rendering slightly for smoother typing
            setTimeout(renderPlayers, 100);
        });

        // Filter tabs
        filterTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // 1. Update active class
                filterTabs.forEach(t => t.classList.remove('tab-active'));
                tab.classList.add('tab-active');

                // 2. Move the indicator
                moveIndicator(tab);
                
                // 3. Update state and re-render players
                currentFilter = tab.dataset.filter;
                renderPlayers();
            });
        });

        // Also move the indicator on window resize for responsiveness
        window.addEventListener('resize', () => {
            const activeTab = document.querySelector('.tab-item.tab-active');
            if (activeTab) {
                 // Use setTimeout to ensure the layout is settled after resize
                setTimeout(() => moveIndicator(activeTab), 50);
            }
        });

        // Initial load is triggered here
        fetchAndParseData();

    </script>
</body>

</html>



